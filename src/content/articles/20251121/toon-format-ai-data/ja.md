---
title: "AIのために設計された新フォーマット「TOON」とは？JSON・YAMLより30-60%トークン削減を実現"
description: "AI/LLM向けに最適化された新しいデータフォーマット「TOON（Token-Oriented Object Notation）」が登場。JSONより最大60%のトークン削減と精度向上を実現し、GitHub18.1k+のスターを獲得。"
date: 2025-11-21
category: "Other"
tags: ["AI", "LLM", "Developer Tools", "開発者ツール", "Open Source", "オープンソース", "Generative AI", "生成AI"]
locale: "ja"
technyanComment: "AIとの会話コストが最大60%削減できるTOON！JSONの冗長な括弧を省いて、テーブルデータはCSV風に。LLMの理解精度も上がるなんて一石二鳥だにゃ！"
---

2025年10月、AI/LLM向けに最適化された新しいデータフォーマット「TOON（Token-Oriented Object Notation）」が公開されました。開発者Johann Schopplichによって作られたこのフォーマットは、JSONと完全な互換性を保ちながら、30-60%のトークン削減を実現し、AIコスト削減の切り札として注目を集めています。

## TOONフォーマットとは？

### 基本概念

TOONは「Token-Oriented Object Notation」の略で、その名の通りトークン効率を最優先に設計されたデータシリアライゼーションフォーマットです。

主な特徴：

- **トークン効率**: JSONより30-60%少ないトークン数（平均40%削減）
- **可逆性**: JSON⇔TOON間で100%ロスレス変換
- **人間可読性**: YAML風の読みやすい構文
- **LLMフレンドリー**: 明示的な構造でAIの理解精度が向上

### 設計思想

TOONは以下の3つの原則に基づいて設計されています：

1. **冗長性の排除**: 括弧、カンマ、引用符などの繰り返しを最小化
2. **構造の明示化**: 配列長やフィールド定義を明示してLLMの解析をサポート
3. **テーブル表現**: 同一構造のデータは1回だけフィールドを宣言

## 主要機能

### 1. YAML風インデントによる階層構造

TOONは、JSONの括弧 `{}` の代わりにインデントで階層を表現します：

**JSON（32トークン）:**
```json
{
  "user": {
    "id": 123,
    "name": "Ada",
    "email": "ada@example.com"
  }
}
```

**TOON（20トークン）:**
```
user:
  id: 123
  name: Ada
  email: ada@example.com
```

トークン削減率: **37.5%**

### 2. CSV風テーブル形式

TOONの最大の特徴は、同一構造を持つ配列のデータをテーブル形式で表現できることです。

**JSON（125トークン）:**
```json
{
  "users": [
    {"id": 1, "name": "Alice", "role": "admin"},
    {"id": 2, "name": "Bob", "role": "user"},
    {"id": 3, "name": "Carol", "role": "user"}
  ]
}
```

**TOON（54トークン）:**
```
users[3]{id,name,role}:
1,Alice,admin
2,Bob,user
3,Carol,user
```

トークン削減率: **56.8%**

構文の解説：
- `users[3]`: 配列名と要素数（3個）
- `{id,name,role}`: フィールド定義（1回だけ宣言）
- 以降の行: 各レコードのデータ（CSV形式）

### 3. 最小限の引用符

TOONは、空白や特殊文字を含まない文字列では引用符を省略できます：

**JSON:**
```json
{
  "status": "active",
  "message": "Hello World"
}
```

**TOON:**
```
status: active
message: Hello World
```

必要な場合のみ引用符を使用：
```
title: "Hello, World!"  # カンマがあるため引用符必要
path: /home/user/file   # スラッシュは引用符不要
```

### 4. プリミティブ配列の簡潔表記

単純な配列も効率的に表現できます：

**JSON:**
```json
{
  "tags": ["admin", "ops", "dev"]
}
```

**TOON:**
```
tags[3]: admin,ops,dev
```

### 5. 代替デリミタによるさらなる最適化

カンマの代わりにタブ（`\t`）やパイプ（`|`）を使うことで、さらにトークンを削減できます：

**タブ区切り:**
```
items[2	]{sku	qty	price}:
A1	2	9.99
B2	1	14.5
```

**パイプ区切り:**
```
items[2|]{sku|qty|price}:
A1|2|9.99
B2|1|14.5
```

## JSON・YAMLとの比較

### 実際のデータでの比較

**ユーザーリストの例:**

| フォーマット | トークン数 | 削減率 |
|------------|----------|--------|
| JSON | 125 | - |
| YAML | 98 | 21.6% |
| TOON | 54 | 56.8% |

**eコマース商品データ（100アイテム）:**

| フォーマット | トークン数 | 削減率 |
|------------|----------|--------|
| JSON | 4,200 | - |
| YAML | 3,800 | 9.5% |
| TOON | 1,800 | 57.1% |

### それぞれのフォーマットの特徴

**JSON:**
- ✅ 最も広く採用されている
- ✅ ツールサポートが充実
- ❌ トークン効率が悪い
- ❌ 冗長な括弧とカンマ

**YAML:**
- ✅ 人間が読みやすい
- ✅ 設定ファイルとして人気
- ⚠️ テーブルデータでもキーを繰り返す
- ❌ 複雑なインデントルール

**TOON:**
- ✅ 最高のトークン効率
- ✅ LLMの理解精度が高い
- ✅ テーブルデータに特に強い
- ⚠️ 新しいフォーマット（エコシステム発展中）
- ❌ 従来のツールとの互換性限定的

## ベンチマーク結果

### トークン削減率

公式ベンチマークによると、データ構造の種類によって削減率が異なります：

- **均一な配列データ**: 50-60%削減
- **ネストされたオブジェクト**: 30-40%削減
- **プリミティブ配列**: 25-35%削減
- **複雑な混合構造**: 20-30%削減

### LLMの理解精度テスト

4つの主要LLM（Claude、GPT-4、Gemini、Grok）で209個のデータ取得質問をテストした結果：

| フォーマット | 平均精度 |
|------------|---------|
| **TOON** | **73.9%** |
| JSON | 69.7% |
| YAML | 71.2% |

TOONは、トークン削減だけでなくLLMの理解精度も向上させることが実証されました。これは、明示的な構造（配列長、フィールド定義）がLLMの検証を助けるためと考えられます。

### コスト削減効果

GPT-4を使用した場合の試算（1Mトークンあたり$30と仮定）：

**シナリオ: 1日10,000回のAPI呼び出し、平均1,000トークン/リクエスト**

| フォーマット | 1日のトークン数 | 月額コスト | 年間コスト |
|------------|----------------|-----------|----------|
| JSON | 10M | $300 | $3,600 |
| TOON | 6M | $180 | $2,160 |
| **削減額** | **4M** | **$120** | **$1,440** |

大規模なAIアプリケーションでは、年間数千ドルのコスト削減が期待できます。

## エコシステムと採用状況

### GitHub統計

- **Stars**: 18.1k+
- **最初のリリース**: 2025年10月
- **仕様バージョン**: v2.0

### 公式実装

**開発中の公式SDK:**
- **TypeScript/JavaScript**: @toon-format/toon（公式実装）
- **Python**
- **Rust**
- **Go**
- **.NET**

### コミュニティ実装

20以上の言語で実装が進行中：
- C++、Clojure、Crystal、Dart、Elixir、Gleam
- Java、Kotlin、Lua、OCaml、PHP、R
- Ruby、Scala、Swift、その他

### 業界採用

- **Openapi.com**: 数週間以内にAPIでTOONサポートを発表
- **スタートアップ**: AI関連スタートアップが実験的に採用
- **LLM開発者コミュニティ**: 急速に認知度が向上

### ツールとリソース

**公式リソース:**
- 公式仕様: https://github.com/toon-format/spec
- TypeScript SDK: https://github.com/toon-format/toon
- 公式サイト: https://toonformat.dev
- NPMパッケージ: @toon-format/toon

**開発ツール:**
- Format Tokenization Playground: トークン数の比較
- TOON Tools: オンライン変換ツール
- ToonParse: パーサーとバリデーター

## 使用推奨ケース

### TOONが最適な場面

1. **LLMとのデータ送受信**
   - ChatGPT、Claude、Geminiなどへのプロンプト
   - AIアプリケーションのレスポンス

2. **均一な配列データ**
   - ユーザーリスト、商品カタログ
   - データベースクエリ結果
   - ログエントリ

3. **時系列データ**
   - 分析データ
   - センサーデータ
   - トランザクションログ

4. **トークンコスト最適化が重要な場面**
   - 大量のAPI呼び出し
   - コンテキストウィンドウの最大活用
   - リアルタイム処理

### TOONを避けるべき場面

1. **深くネストされた構造（3階層以上）**
   - JSONの方が効率的な場合がある
   - インデントが複雑になりすぎる

2. **従来のREST API**
   - JSONが標準
   - ツールサポートが必要

3. **不均一/不規則なデータ**
   - テーブル形式のメリットが活かせない
   - 各レコードで異なるフィールドを持つデータ

4. **データベースやファイルストレージ**
   - 既存のJSONサポートを活用すべき
   - 互換性が重要

5. **ユニバーサルなツール互換性が必要**
   - JSONやYAMLの方が安全

## 始め方

### TypeScript/JavaScriptでの使用

**インストール:**
```bash
npm install @toon-format/toon
```

**基本的な使用例:**
```typescript
import { stringify, parse } from '@toon-format/toon';

// JSONからTOONに変換
const data = {
  users: [
    { id: 1, name: "Alice", role: "admin" },
    { id: 2, name: "Bob", role: "user" }
  ]
};

const toonString = stringify(data);
console.log(toonString);
// 出力:
// users[2]{id,name,role}:
// 1,Alice,admin
// 2,Bob,user

// TOONからJSONに変換
const parsedData = parse(toonString);
console.log(parsedData);
// 元のJSONオブジェクトに戻る
```

### OpenAI APIでの使用例

```typescript
import OpenAI from 'openai';
import { stringify } from '@toon-format/toon';

const client = new OpenAI();

const userData = {
  users: [/* 大量のユーザーデータ */]
};

const response = await client.chat.completions.create({
  model: "gpt-4",
  messages: [
    {
      role: "user",
      content: `以下のユーザーデータを分析してください:\n\n${stringify(userData)}`
    }
  ]
});

// トークン使用量を確認
console.log(`使用トークン: ${response.usage.total_tokens}`);
// JSONと比較して30-60%削減される
```

## テクにゃんのコメント

「TOONフォーマット、これは本当に画期的だにゃ！AIとの会話コストを最大60%も削減できるなんて、特に大量のデータを扱うアプリケーションでは革命的だにゃん！

まず驚いたのは、トークン削減だけじゃなくて、LLMの理解精度まで上がっている点だにゃ。TOONの73.9%に対してJSONは69.7%って、約4ポイントも差があるにゃ！これは `users[3]{id,name,role}` みたいに、配列の長さやフィールドを明示することで、LLMが構造を検証しやすくなっているからだね。

特にテーブル形式のデータ表現が素晴らしいにゃ！JSONだと同じキー（`id`、`name`、`role`）を何度も繰り返し書かないといけないけど、TOONなら1回だけ宣言して、あとはCSV風にデータだけ並べればいい。これは特にデータベースのクエリ結果とか、ログデータとか、商品リストみたいな均一な構造のデータに超強力だにゃん！

実際のコスト削減効果も見逃せないにゃ。年間$1,440の削減って、スタートアップにとっては結構大きな額だし、大企業ならもっと桁が違うはずだにゃ。それに、トークンを節約できるってことは、コンテキストウィンドウにもっと多くの情報を詰め込めるってことだから、AIの性能向上にも繋がるね。

ただし、まだ新しいフォーマットだから、採用にはいくつか注意点があるにゃ：

1. **エコシステムがまだ発展中**: JSONみたいに何でもかんでもサポートしているわけじゃないから、ツールの互換性には注意が必要だにゃ。

2. **学習コスト**: チームメンバーが新しいフォーマットを学ぶ必要がある。でも、構文自体はシンプルだから、学習コストは低いと思うにゃ。

3. **最適な用途を見極める**: 深くネストされた複雑な構造には向いてないから、使いどころを選ぶことが大事だにゃ。

個人的に面白いと思うのは、タブやパイプをデリミタとして使えること。カンマって実は多くのトークナイザーで1トークンとして扱われるから、それをタブに置き換えることで、さらに効率化できる可能性があるんだにゃ。ただし、タブは可視性が低いから、デバッグが難しくなる可能性もあるね。

GitHub Starsが18.1k+って、リリースから2ヶ月でこの数字はすごいにゃ！コミュニティの勢いを感じるね。20以上の言語で実装が進んでいることからも、開発者コミュニティの関心の高さが伺えるにゃん。

Openapi.comが数週間以内にサポートを発表するって情報も注目だにゃ。大手プラットフォームが採用し始めれば、一気に普及する可能性がある。ただし、標準化されるまでには時間がかかるから、今の段階では「LLMとの通信専用」として使うのが賢明だと思うにゃ。

結論として、TOONは以下のような場面で今すぐ使うべきだにゃ：

✅ **LLMへのデータ送信**: ChatGPT、Claude、GeminiなどのAPIを頻繁に使う場合
✅ **均一なデータ構造**: ユーザーリスト、商品カタログ、ログデータなど
✅ **コスト削減**: トークン使用量が多く、コストが気になる場合
✅ **コンテキスト最大化**: 限られたコンテキストウィンドウに多くの情報を詰め込みたい場合

逆に、以下の場合は従来のJSONを使い続けるべきだにゃ：

❌ **REST API**: 外部公開APIではJSONが標準
❌ **複雑なネスト**: 3階層以上のネストが多い場合
❌ **不規則なデータ**: 各レコードで構造が異なる場合
❌ **既存ツールとの互換性**: JSONパーサーやバリデーターが必須の場合

TOONは、AIファーストの時代における新しい標準になる可能性を秘めているにゃ。今はまだ早期採用者のフェーズだけど、LLM開発者なら絶対にウォッチしておくべき技術だにゃん！🚀📊」

## まとめ

TOONフォーマットは、AI時代の新しいデータ表現手法として大きな可能性を秘めています：

1. **驚異的なトークン削減**: JSONより30-60%、平均40%のトークン削減を実現
2. **精度向上**: LLMの理解精度が73.9%（JSON: 69.7%）に向上
3. **コスト削減**: 大規模アプリケーションで年間数千ドルのAPI コスト削減
4. **急速な普及**: リリース2ヶ月でGitHub 18.1k+スター、20以上の言語で実装進行中
5. **実用的**: Openapi.comなど大手プラットフォームが採用予定

TOONは、特に均一な構造のデータをLLMとやり取りする場面で真価を発揮します。トークンコストの削減だけでなく、AIの理解精度向上という副次的な効果も実証されており、AI/LLMアプリケーション開発者にとって注目すべき技術です。

まだ新しいフォーマットではありますが、明確な利点と急速に拡大するエコシステムを考えると、今後のAI開発における標準的な選択肢の一つとなる可能性が高いでしょう。特に、トークン効率が重要な大規模AIアプリケーションでは、早期導入による競争優位性を得られる可能性があります。
